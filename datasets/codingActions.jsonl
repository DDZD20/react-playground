[
  [
    { "type": "type", "content": "function twoSum(nums, target)", "timestamp": 0, "duration": 600 },
    { "type": "type", "content": " {", "timestamp": 600, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 700, "duration": 500 },
    { "type": "type", "content": "\n  let res = [];", "timestamp": 1200, "duration": 300 },
    { "type": "wait", "content": "", "timestamp": 1500, "duration": 300 },
    { "type": "type", "content": "\n  for (let i = 0; i < nums.length; i++) {", "timestamp": 1800, "duration": 500 },
    { "type": "wait", "content": "", "timestamp": 2300, "duration": 200 },
    { "type": "type", "content": "\n    for (let j = i + 1; j < nums.length; j++) {", "timestamp": 2500, "duration": 400 },
    { "type": "wait", "content": "", "timestamp": 2900, "duration": 300 },
    { "type": "type", "content": "\n      if (nums[i] + nums[j] === target)", "timestamp": 3200, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 3600, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 3650, "duration": 200 },
    { "type": "type", "content": "\n        res = [i, j];", "timestamp": 3850, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 4050, "duration": 150 },
    { "type": "type", "content": "\n      }", "timestamp": 4200, "duration": 50 },
    { "type": "type", "content": "\n    }", "timestamp": 4250, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 4300, "duration": 200 },
    { "type": "type", "content": "\n  }", "timestamp": 4500, "duration": 50 },
    { "type": "type", "content": "\n  return res;", "timestamp": 4550, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 4650, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 4700, "duration": 400 },
    { "type": "completion", "content": "function twoSum(nums, target) {\n  let res = [];\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        res = [i, j];\n      }\n    }\n  }\n  return res;\n}", "timestamp": 5100, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function twoSum(nums, target)", "timestamp": 0, "duration": 600 },
    { "type": "type", "content": " {", "timestamp": 600, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 700, "duration": 500 },
    { "type": "type", "content": "\n  const map = {};", "timestamp": 1200, "duration": 500 },
    { "type": "wait", "content": "", "timestamp": 1700, "duration": 300 },
    { "type": "type", "content": "\n  for (let i = 0; i < nums.length; i++) {", "timestamp": 2000, "duration": 600 },
    { "type": "wait", "content": "", "timestamp": 2600, "duration": 400 },
    { "type": "type", "content": "\n    const complement = target - nums[i];", "timestamp": 3000, "duration": 400 },
    { "type": "wait", "content": "", "timestamp": 3400, "duration": 300 },
    { "type": "type", "content": "\n    if (map.hasOwnProperty(complement)) {", "timestamp": 3700, "duration": 500 },
    { "type": "type", "content": "\n      return [map[complement], i];", "timestamp": 4200, "duration": 200 },
    { "type": "type", "content": "\n    }", "timestamp": 4400, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 4450, "duration": 200 },
    { "type": "type", "content": "\n    map[nums[i]] = i;", "timestamp": 4650, "duration": 200 },
    { "type": "type", "content": "\n  }", "timestamp": 4850, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 4900, "duration": 300 },
    { "type": "type", "content": "\n}", "timestamp": 5200, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 5250, "duration": 500 },
    { "type": "completion", "content": "function twoSum(nums, target) {\n  const map = {};\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.hasOwnProperty(complement)) {\n      return [map[complement], i];\n    }\n    map[nums[i]] = i;\n  }\n}", "timestamp": 5750, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function twoSum(nums, target)", "timestamp": 0, "duration": 600 },
    { "type": "type", "content": " {", "timestamp": 600, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 700, "duration": 500 },
    { "type": "type", "content": "\n  let res = [];", "timestamp": 1200, "duration": 300 },
    { "type": "wait", "content": "", "timestamp": 1500, "duration": 300 },
    { "type": "type", "content": "\n  for (let i = 0; i < nums.length; i++) {", "timestamp": 1800, "duration": 500 },
    { "type": "wait", "content": "", "timestamp": 2300, "duration": 200 },
    { "type": "type", "content": "\n    for (let j = i + 1; j < nums.length; j++) {", "timestamp": 2500, "duration": 400 },
    { "type": "wait", "content": "", "timestamp": 2900, "duration": 300 },
    { "type": "type", "content": "\n      if (nums[i] + nums[j] === target)", "timestamp": 3200, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 3600, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 3650, "duration": 200 },
    { "type": "type", "content": "\n        res = [i, j];", "timestamp": 3850, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 4050, "duration": 150 },
    { "type": "type", "content": "\n      }", "timestamp": 4200, "duration": 50 },
    { "type": "type", "content": "\n    }", "timestamp": 4250, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 4300, "duration": 200 },
    { "type": "type", "content": "\n  }", "timestamp": 4500, "duration": 50 },
    { "type": "type", "content": "\n  return res;", "timestamp": 4550, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 4650, "duration": 50 },
    { "type": "wait", "content": "", "timestamp": 4700, "duration": 400 },
    { "type": "completion", "content": "function twoSum(nums, target) {\n  let res = [];\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        res = [i, j];\n      }\n    }\n  }\n  return res;\n}", "timestamp": 5100, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function reverseString(s)", "timestamp": 0, "duration": 300 },
    { "type": "type", "content": " {", "timestamp": 300, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 400, "duration": 200 },
    { "type": "type", "content": "\n  let left = 0;", "timestamp": 600, "duration": 200 },
    { "type": "type", "content": "\n  let right = s.length - 1;", "timestamp": 800, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 1000, "duration": 300 },
    { "type": "type", "content": "\n  while (left < right) {", "timestamp": 1300, "duration": 200 },
    { "type": "type", "content": "\n    [s[left], s[right]] = [s[right], s[left]];", "timestamp": 1500, "duration": 200 },
    { "type": "type", "content": "\n    left++;", "timestamp": 1700, "duration": 100 },
    { "type": "type", "content": "\n    right--;", "timestamp": 1800, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1900, "duration": 100 },
    { "type": "type", "content": "\n  return s;", "timestamp": 2000, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 2100, "duration": 100 },
    { "type": "completion", "content": "function reverseString(s) {\n  let left = 0;\n  let right = s.length - 1;\n  while (left < right) {\n    [s[left], s[right]] = [s[right], s[left]];\n    left++;\n    right--;\n  }\n  return s;\n}", "timestamp": 2200, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function isPalindrome(x)", "timestamp": 0, "duration": 300 },
    { "type": "type", "content": " {", "timestamp": 300, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 400, "duration": 200 },
    { "type": "type", "content": "\n  const s = x.toString();", "timestamp": 600, "duration": 200 },
    { "type": "type", "content": "\n  let l = 0, r = s.length - 1;", "timestamp": 800, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 1000, "duration": 200 },
    { "type": "type", "content": "\n  while (l < r) {", "timestamp": 1200, "duration": 100 },
    { "type": "type", "content": "\n    if (s[l] !== s[r]) return false;", "timestamp": 1300, "duration": 150 },
    { "type": "type", "content": "\n    l++; r--;", "timestamp": 1450, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1550, "duration": 100 },
    { "type": "type", "content": "\n  return true;", "timestamp": 1650, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1750, "duration": 100 },
    { "type": "completion", "content": "function isPalindrome(x) {\n  const s = x.toString();\n  let l = 0, r = s.length - 1;\n  while (l < r) {\n    if (s[l] !== s[r]) return false;\n    l++; r--;\n  }\n  return true;\n}", "timestamp": 1850, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function maxSubArray(nums)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  let max = nums[0];", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  let sum = 0;", "timestamp": 900, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 1000, "duration": 200 },
    { "type": "type", "content": "\n  for (let n of nums) {", "timestamp": 1200, "duration": 200 },
    { "type": "type", "content": "\n    sum = Math.max(n, sum + n);", "timestamp": 1400, "duration": 200 },
    { "type": "type", "content": "\n    max = Math.max(max, sum);", "timestamp": 1600, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1700, "duration": 100 },
    { "type": "type", "content": "\n  return max;", "timestamp": 1800, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1900, "duration": 100 },
    { "type": "completion", "content": "function maxSubArray(nums) {\n  let max = nums[0];\n  let sum = 0;\n  for (let n of nums) {\n    sum = Math.max(n, sum + n);\n    max = Math.max(max, sum);\n  }\n  return max;\n}", "timestamp": 2000, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function climbStairs(n)", "timestamp": 0, "duration": 300 },
    { "type": "type", "content": " {", "timestamp": 300, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 400, "duration": 200 },
    { "type": "type", "content": "\n  let a = 1, b = 1;", "timestamp": 600, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 800, "duration": 200 },
    { "type": "type", "content": "\n  for (let i = 2; i <= n; i++) {", "timestamp": 1000, "duration": 200 },
    { "type": "type", "content": "\n    let t = a + b;", "timestamp": 1200, "duration": 100 },
    { "type": "type", "content": "\n    a = b;", "timestamp": 1300, "duration": 100 },
    { "type": "type", "content": "\n    b = t;", "timestamp": 1400, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1500, "duration": 100 },
    { "type": "type", "content": "\n  return b;", "timestamp": 1600, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1700, "duration": 100 },
    { "type": "completion", "content": "function climbStairs(n) {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    let t = a + b;\n    a = b;\n    b = t;\n  }\n  return b;\n}", "timestamp": 1800, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function mergeTwoLists(l1, l2)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  let dummy = { val: 0, next: null }, cur = dummy;", "timestamp": 700, "duration": 300 },
    { "type": "type", "content": "\n  while (l1 && l2) {", "timestamp": 1000, "duration": 200 },
    { "type": "type", "content": "\n    if (l1.val < l2.val) {", "timestamp": 1200, "duration": 150 },
    { "type": "type", "content": "\n      cur.next = l1; l1 = l1.next;", "timestamp": 1350, "duration": 150 },
    { "type": "type", "content": "\n    } else {", "timestamp": 1500, "duration": 100 },
    { "type": "type", "content": "\n      cur.next = l2; l2 = l2.next;", "timestamp": 1600, "duration": 100 },
    { "type": "type", "content": "\n    }", "timestamp": 1700, "duration": 100 },
    { "type": "type", "content": "\n    cur = cur.next;", "timestamp": 1800, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1900, "duration": 100 },
    { "type": "type", "content": "\n  cur.next = l1 || l2;", "timestamp": 2000, "duration": 100 },
    { "type": "type", "content": "\n  return dummy.next;", "timestamp": 2100, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 2200, "duration": 100 },
    { "type": "completion", "content": "function mergeTwoLists(l1, l2) {\n  let dummy = { val: 0, next: null }, cur = dummy;\n  while (l1 && l2) {\n    if (l1.val < l2.val) {\n      cur.next = l1; l1 = l1.next;\n    } else {\n      cur.next = l2; l2 = l2.next;\n    }\n    cur = cur.next;\n  }\n  cur.next = l1 || l2;\n  return dummy.next;\n}", "timestamp": 2300, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function removeDuplicates(nums)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  let i = 0;", "timestamp": 700, "duration": 100 },
    { "type": "type", "content": "\n  for (let j = 1; j < nums.length; j++) {", "timestamp": 800, "duration": 300 },
    { "type": "type", "content": "\n    if (nums[j] !== nums[i]) {", "timestamp": 1100, "duration": 150 },
    { "type": "type", "content": "\n      i++; nums[i] = nums[j];", "timestamp": 1250, "duration": 150 },
    { "type": "type", "content": "\n    }", "timestamp": 1400, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1500, "duration": 100 },
    { "type": "type", "content": "\n  return i + 1;", "timestamp": 1600, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1700, "duration": 100 },
    { "type": "completion", "content": "function removeDuplicates(nums) {\n  let i = 0;\n  for (let j = 1; j < nums.length; j++) {\n    if (nums[j] !== nums[i]) {\n      i++; nums[i] = nums[j];\n    }\n  }\n  return i + 1;\n}", "timestamp": 1800, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function moveZeroes(nums)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  let last = 0;", "timestamp": 700, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 800, "duration": 200 },
    { "type": "type", "content": "\n  for (let i = 0; i < nums.length; i++) {", "timestamp": 1000, "duration": 200 },
    { "type": "type", "content": "\n    if (nums[i] !== 0) {", "timestamp": 1200, "duration": 100 },
    { "type": "type", "content": "\n      [nums[last], nums[i]] = [nums[i], nums[last]];", "timestamp": 1300, "duration": 150 },
    { "type": "type", "content": "\n      last++;", "timestamp": 1450, "duration": 100 },
    { "type": "type", "content": "\n    }", "timestamp": 1550, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1650, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1750, "duration": 100 },
    { "type": "completion", "content": "function moveZeroes(nums) {\n  let last = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      [nums[last], nums[i]] = [nums[i], nums[last]];\n      last++;\n    }\n  }\n}", "timestamp": 1850, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function maxProfit(prices)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  let min = prices[0], max = 0;", "timestamp": 700, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 900, "duration": 200 },
    { "type": "type", "content": "\n  for (let p of prices) {", "timestamp": 1100, "duration": 200 },
    { "type": "type", "content": "\n    min = Math.min(min, p);", "timestamp": 1300, "duration": 100 },
    { "type": "type", "content": "\n    max = Math.max(max, p - min);", "timestamp": 1400, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1500, "duration": 100 },
    { "type": "type", "content": "\n  return max;", "timestamp": 1600, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1700, "duration": 100 },
    { "type": "completion", "content": "function maxProfit(prices) {\n  let min = prices[0], max = 0;\n  for (let p of prices) {\n    min = Math.min(min, p);\n    max = Math.max(max, p - min);\n  }\n  return max;\n}", "timestamp": 1800, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function containsDuplicate(nums)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  const set = new Set();", "timestamp": 700, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 900, "duration": 200 },
    { "type": "type", "content": "\n  for (let n of nums) {", "timestamp": 1100, "duration": 200 },
    { "type": "type", "content": "\n    if (set.has(n)) return true;", "timestamp": 1300, "duration": 150 },
    { "type": "type", "content": "\n    set.add(n);", "timestamp": 1450, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1550, "duration": 100 },
    { "type": "type", "content": "\n  return false;", "timestamp": 1650, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1750, "duration": 100 },
    { "type": "completion", "content": "function containsDuplicate(nums) {\n  const set = new Set();\n  for (let n of nums) {\n    if (set.has(n)) return true;\n    set.add(n);\n  }\n  return false;\n}", "timestamp": 1850, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function intersect(nums1, nums2)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  const map = {};", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  for (let n of nums1) map[n] = (map[n] || 0) + 1;", "timestamp": 900, "duration": 200 },
    { "type": "type", "content": "\n  const res = [];", "timestamp": 1100, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 1200, "duration": 200 },
    { "type": "type", "content": "\n  for (let n of nums2) {", "timestamp": 1400, "duration": 200 },
    { "type": "type", "content": "\n    if (map[n]) {", "timestamp": 1600, "duration": 100 },
    { "type": "type", "content": "\n      res.push(n); map[n]--;", "timestamp": 1700, "duration": 150 },
    { "type": "type", "content": "\n    }", "timestamp": 1850, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1950, "duration": 100 },
    { "type": "type", "content": "\n  return res;", "timestamp": 2050, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 2150, "duration": 100 },
    { "type": "completion", "content": "function intersect(nums1, nums2) {\n  const map = {};\n  for (let n of nums1) map[n] = (map[n] || 0) + 1;\n  const res = [];\n  for (let n of nums2) {\n    if (map[n]) {\n      res.push(n); map[n]--;\n    }\n  }\n  return res;\n}", "timestamp": 2250, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function minDepth(root)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  if (!root) return 0;", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  if (!root.left) return minDepth(root.right) + 1;", "timestamp": 900, "duration": 250 },
    { "type": "type", "content": "\n  if (!root.right) return minDepth(root.left) + 1;", "timestamp": 1150, "duration": 250 },
    { "type": "type", "content": "\n  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;", "timestamp": 1400, "duration": 300 },
    { "type": "type", "content": "\n}", "timestamp": 1700, "duration": 100 },
    { "type": "completion", "content": "function minDepth(root) {\n  if (!root) return 0;\n  if (!root.left) return minDepth(root.right) + 1;\n  if (!root.right) return minDepth(root.left) + 1;\n  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n}", "timestamp": 1800, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function binarySearch(nums, target)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  let l = 0, r = nums.length - 1;", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  while (l <= r) {", "timestamp": 900, "duration": 200 },
    { "type": "type", "content": "\n    const m = Math.floor((l + r) / 2);", "timestamp": 1100, "duration": 150 },
    { "type": "type", "content": "\n    if (nums[m] === target) return m;", "timestamp": 1250, "duration": 150 },
    { "type": "type", "content": "\n    if (nums[m] < target) l = m + 1;", "timestamp": 1400, "duration": 150 },
    { "type": "type", "content": "\n    else r = m - 1;", "timestamp": 1550, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1650, "duration": 100 },
    { "type": "type", "content": "\n  return -1;", "timestamp": 1750, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1850, "duration": 100 },
    { "type": "completion", "content": "function binarySearch(nums, target) {\n  let l = 0, r = nums.length - 1;\n  while (l <= r) {\n    const m = Math.floor((l + r) / 2);\n    if (nums[m] === target) return m;\n    if (nums[m] < target) l = m + 1;\n    else r = m - 1;\n  }\n  return -1;\n}", "timestamp": 1950, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function isValid(s)", "timestamp": 0, "duration": 300 },
    { "type": "type", "content": " {", "timestamp": 300, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 400, "duration": 200 },
    { "type": "type", "content": "\n  const stack = [];", "timestamp": 600, "duration": 200 },
    { "type": "type", "content": "\n  const map = {')':'(', ']':'[', '}':'{'};", "timestamp": 800, "duration": 250 },
    { "type": "wait", "content": "", "timestamp": 1050, "duration": 150 },
    { "type": "type", "content": "\n  for (let c of s) {", "timestamp": 1200, "duration": 200 },
    { "type": "type", "content": "\n    if (Object.values(map).includes(c)) stack.push(c);", "timestamp": 1400, "duration": 200 },
    { "type": "type", "content": "\n    else if (!stack.length || stack.pop() !== map[c]) return false;", "timestamp": 1600, "duration": 250 },
    { "type": "type", "content": "\n  }", "timestamp": 1850, "duration": 100 },
    { "type": "type", "content": "\n  return !stack.length;", "timestamp": 1950, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 2050, "duration": 100 },
    { "type": "completion", "content": "function isValid(s) {\n  const stack = [];\n  const map = {')':'(', ']':'[', '}':'{'};\n  for (let c of s) {\n    if (Object.values(map).includes(c)) stack.push(c);\n    else if (!stack.length || stack.pop() !== map[c]) return false;\n  }\n  return !stack.length;\n}", "timestamp": 2150, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function mergeIntervals(intervals)", "timestamp": 0, "duration": 500 },
    { "type": "type", "content": " {", "timestamp": 500, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 600, "duration": 200 },
    { "type": "type", "content": "\n  if (!intervals.length) return [];", "timestamp": 800, "duration": 200 },
    { "type": "type", "content": "\n  intervals.sort((a, b) => a[0] - b[0]);", "timestamp": 1000, "duration": 200 },
    { "type": "type", "content": "\n  const res = [intervals[0]];", "timestamp": 1200, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 1400, "duration": 200 },
    { "type": "type", "content": "\n  for (let i = 1; i < intervals.length; i++) {", "timestamp": 1600, "duration": 200 },
    { "type": "type", "content": "\n    const prev = res[res.length - 1];", "timestamp": 1800, "duration": 150 },
    { "type": "type", "content": "\n    if (intervals[i][0] <= prev[1]) {", "timestamp": 1950, "duration": 150 },
    { "type": "type", "content": "\n      prev[1] = Math.max(prev[1], intervals[i][1]);", "timestamp": 2100, "duration": 150 },
    { "type": "type", "content": "\n    } else {", "timestamp": 2250, "duration": 100 },
    { "type": "type", "content": "\n      res.push(intervals[i]);", "timestamp": 2350, "duration": 100 },
    { "type": "type", "content": "\n    }", "timestamp": 2450, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 2550, "duration": 100 },
    { "type": "type", "content": "\n  return res;", "timestamp": 2650, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 2750, "duration": 100 },
    { "type": "completion", "content": "function mergeIntervals(intervals) {\n  if (!intervals.length) return [];\n  intervals.sort((a, b) => a[0] - b[0]);\n  const res = [intervals[0]];\n  for (let i = 1; i < intervals.length; i++) {\n    const prev = res[res.length - 1];\n    if (intervals[i][0] <= prev[1]) {\n      prev[1] = Math.max(prev[1], intervals[i][1]);\n    } else {\n      res.push(intervals[i]);\n    }\n  }\n  return res;\n}", "timestamp": 2850, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function quickSort(arr)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  if (arr.length <= 1) return arr;", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  const pivot = arr[0];", "timestamp": 900, "duration": 150 },
    { "type": "type", "content": "\n  const left = arr.slice(1).filter(x => x < pivot);", "timestamp": 1050, "duration": 200 },
    { "type": "type", "content": "\n  const right = arr.slice(1).filter(x => x >= pivot);", "timestamp": 1250, "duration": 200 },
    { "type": "wait", "content": "", "timestamp": 1450, "duration": 200 },
    { "type": "type", "content": "\n  return [...quickSort(left), pivot, ...quickSort(right)];", "timestamp": 1650, "duration": 200 },
    { "type": "type", "content": "\n}", "timestamp": 1850, "duration": 100 },
    { "type": "completion", "content": "function quickSort(arr) {\n  if (arr.length <= 1) return arr;\n  const pivot = arr[0];\n  const left = arr.slice(1).filter(x => x < pivot);\n  const right = arr.slice(1).filter(x => x >= pivot);\n  return [...quickSort(left), pivot, ...quickSort(right)];\n}", "timestamp": 1950, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function subsets(nums)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  const res = [[]];", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  for (let n of nums) {", "timestamp": 900, "duration": 200 },
    { "type": "type", "content": "\n    res.push(...res.map(arr => [...arr, n]));", "timestamp": 1100, "duration": 200 },
    { "type": "type", "content": "\n  }", "timestamp": 1300, "duration": 100 },
    { "type": "type", "content": "\n  return res;", "timestamp": 1400, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1500, "duration": 100 },
    { "type": "completion", "content": "function subsets(nums) {\n  const res = [[]];\n  for (let n of nums) {\n    res.push(...res.map(arr => [...arr, n]));\n  }\n  return res;\n}", "timestamp": 1600, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function permute(nums)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  const res = [];", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  const dfs = (path, used) => {", "timestamp": 900, "duration": 200 },
    { "type": "type", "content": "\n    if (path.length === nums.length) {", "timestamp": 1100, "duration": 150 },
    { "type": "type", "content": "\n      res.push([...path]);", "timestamp": 1250, "duration": 100 },
    { "type": "type", "content": "\n      return;", "timestamp": 1350, "duration": 100 },
    { "type": "type", "content": "\n    }", "timestamp": 1450, "duration": 100 },
    { "type": "type", "content": "\n    for (let i = 0; i < nums.length; i++) {", "timestamp": 1550, "duration": 200 },
    { "type": "type", "content": "\n      if (used[i]) continue;", "timestamp": 1750, "duration": 100 },
    { "type": "type", "content": "\n      used[i] = true; path.push(nums[i]);", "timestamp": 1850, "duration": 150 },
    { "type": "type", "content": "\n      dfs(path, used);", "timestamp": 2000, "duration": 100 },
    { "type": "type", "content": "\n      path.pop(); used[i] = false;", "timestamp": 2100, "duration": 150 },
    { "type": "type", "content": "\n    }", "timestamp": 2250, "duration": 100 },
    { "type": "type", "content": "\n  };", "timestamp": 2350, "duration": 100 },
    { "type": "type", "content": "\n  dfs([], Array(nums.length).fill(false));", "timestamp": 2450, "duration": 150 },
    { "type": "type", "content": "\n  return res;", "timestamp": 2600, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 2700, "duration": 100 },
    { "type": "completion", "content": "function permute(nums) {\n  const res = [];\n  const dfs = (path, used) => {\n    if (path.length === nums.length) {\n      res.push([...path]);\n      return;\n    }\n    for (let i = 0; i < nums.length; i++) {\n      if (used[i]) continue;\n      used[i] = true; path.push(nums[i]);\n      dfs(path, used);\n      path.pop(); used[i] = false;\n    }\n  };\n  dfs([], Array(nums.length).fill(false));\n  return res;\n}", "timestamp": 2800, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function maxProduct(nums)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  let res = nums[0], curMin = nums[0], curMax = nums[0];", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  for (let i = 1; i < nums.length; i++) {", "timestamp": 900, "duration": 200 },
    { "type": "type", "content": "\n    const tmp = curMax;", "timestamp": 1100, "duration": 100 },
    { "type": "type", "content": "\n    curMax = Math.max(nums[i], curMax * nums[i], curMin * nums[i]);", "timestamp": 1200, "duration": 200 },
    { "type": "type", "content": "\n    curMin = Math.min(nums[i], tmp * nums[i], curMin * nums[i]);", "timestamp": 1400, "duration": 200 },
    { "type": "type", "content": "\n    res = Math.max(res, curMax);", "timestamp": 1600, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1700, "duration": 100 },
    { "type": "type", "content": "\n  return res;", "timestamp": 1800, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1900, "duration": 100 },
    { "type": "completion", "content": "function maxProduct(nums) {\n  let res = nums[0], curMin = nums[0], curMax = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const tmp = curMax;\n    curMax = Math.max(nums[i], curMax * nums[i], curMin * nums[i]);\n    curMin = Math.min(nums[i], tmp * nums[i], curMin * nums[i]);\n    res = Math.max(res, curMax);\n  }\n  return res;\n}", "timestamp": 2000, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function coinChange(coins, amount)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  const dp = Array(amount + 1).fill(Infinity);", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  dp[0] = 0;", "timestamp": 900, "duration": 100 },
    { "type": "type", "content": "\n  for (let coin of coins) {", "timestamp": 1000, "duration": 200 },
    { "type": "type", "content": "\n    for (let i = coin; i <= amount; i++) {", "timestamp": 1200, "duration": 200 },
    { "type": "type", "content": "\n      dp[i] = Math.min(dp[i], dp[i - coin] + 1);", "timestamp": 1400, "duration": 200 },
    { "type": "type", "content": "\n    }", "timestamp": 1600, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1700, "duration": 100 },
    { "type": "type", "content": "\n  return dp[amount] === Infinity ? -1 : dp[amount];", "timestamp": 1800, "duration": 200 },
    { "type": "type", "content": "\n}", "timestamp": 2000, "duration": 100 },
    { "type": "completion", "content": "function coinChange(coins, amount) {\n  const dp = Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let coin of coins) {\n    for (let i = coin; i <= amount; i++) {\n      dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}", "timestamp": 2100, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function findPeakElement(nums)", "timestamp": 0, "duration": 300 },
    { "type": "type", "content": " {", "timestamp": 300, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 400, "duration": 200 },
    { "type": "type", "content": "\n  let l = 0, r = nums.length - 1;", "timestamp": 600, "duration": 200 },
    { "type": "type", "content": "\n  while (l < r) {", "timestamp": 800, "duration": 200 },
    { "type": "type", "content": "\n    const m = Math.floor((l + r) / 2);", "timestamp": 1000, "duration": 150 },
    { "type": "type", "content": "\n    if (nums[m] > nums[m + 1]) r = m;", "timestamp": 1150, "duration": 150 },
    { "type": "type", "content": "\n    else l = m + 1;", "timestamp": 1300, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 1400, "duration": 100 },
    { "type": "type", "content": "\n  return l;", "timestamp": 1500, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1600, "duration": 100 },
    { "type": "completion", "content": "function findPeakElement(nums) {\n  let l = 0, r = nums.length - 1;\n  while (l < r) {\n    const m = Math.floor((l + r) / 2);\n    if (nums[m] > nums[m + 1]) r = m;\n    else l = m + 1;\n  }\n  return l;\n}", "timestamp": 1700, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function canJump(nums)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  let farthest = 0;", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  for (let i = 0; i < nums.length; i++) {", "timestamp": 900, "duration": 200 },
    { "type": "type", "content": "\n    if (i > farthest) return false;", "timestamp": 1100, "duration": 150 },
    { "type": "type", "content": "\n    farthest = Math.max(farthest, i + nums[i]);", "timestamp": 1250, "duration": 150 },
    { "type": "type", "content": "\n  }", "timestamp": 1400, "duration": 100 },
    { "type": "type", "content": "\n  return true;", "timestamp": 1500, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 1600, "duration": 100 },
    { "type": "completion", "content": "function canJump(nums) {\n  let farthest = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (i > farthest) return false;\n    farthest = Math.max(farthest, i + nums[i]);\n  }\n  return true;\n}", "timestamp": 1700, "duration": 0, "isCommit": true }
  ],
  [
    { "type": "type", "content": "function spiralOrder(matrix)", "timestamp": 0, "duration": 400 },
    { "type": "type", "content": " {", "timestamp": 400, "duration": 100 },
    { "type": "wait", "content": "", "timestamp": 500, "duration": 200 },
    { "type": "type", "content": "\n  if (!matrix.length) return [];", "timestamp": 700, "duration": 200 },
    { "type": "type", "content": "\n  let res = [], top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1;", "timestamp": 900, "duration": 300 },
    { "type": "wait", "content": "", "timestamp": 1200, "duration": 200 },
    { "type": "type", "content": "\n  while (top <= bottom && left <= right) {", "timestamp": 1400, "duration": 200 },
    { "type": "type", "content": "\n    for (let i = left; i <= right; i++) res.push(matrix[top][i]);", "timestamp": 1600, "duration": 200 },
    { "type": "type", "content": "\n    top++;", "timestamp": 1800, "duration": 100 },
    { "type": "type", "content": "\n    for (let i = top; i <= bottom; i++) res.push(matrix[i][right]);", "timestamp": 1900, "duration": 200 },
    { "type": "type", "content": "\n    right--;", "timestamp": 2100, "duration": 100 },
    { "type": "type", "content": "\n    if (top <= bottom) {", "timestamp": 2200, "duration": 100 },
    { "type": "type", "content": "\n      for (let i = right; i >= left; i--) res.push(matrix[bottom][i]);", "timestamp": 2300, "duration": 200 },
    { "type": "type", "content": "\n      bottom--;", "timestamp": 2500, "duration": 100 },
    { "type": "type", "content": "\n    }", "timestamp": 2600, "duration": 100 },
    { "type": "type", "content": "\n    if (left <= right) {", "timestamp": 2700, "duration": 100 },
    { "type": "type", "content": "\n      for (let i = bottom; i >= top; i--) res.push(matrix[i][left]);", "timestamp": 2800, "duration": 200 },
    { "type": "type", "content": "\n      left++;", "timestamp": 3000, "duration": 100 },
    { "type": "type", "content": "\n    }", "timestamp": 3100, "duration": 100 },
    { "type": "type", "content": "\n  }", "timestamp": 3200, "duration": 100 },
    { "type": "type", "content": "\n  return res;", "timestamp": 3300, "duration": 100 },
    { "type": "type", "content": "\n}", "timestamp": 3400, "duration": 100 },
    { "type": "completion", "content": "function spiralOrder(matrix) {\n  if (!matrix.length) return [];\n  let res = [], top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1;\n  while (top <= bottom && left <= right) {\n    for (let i = left; i <= right; i++) res.push(matrix[top][i]);\n    top++;\n    for (let i = top; i <= bottom; i++) res.push(matrix[i][right]);\n    right--;\n    if (top <= bottom) {\n      for (let i = right; i >= left; i--) res.push(matrix[bottom][i]);\n      bottom--;\n    }\n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) res.push(matrix[i][left]);\n      left++;\n    }\n  }\n  return res;\n}", "timestamp": 3500, "duration": 0, "isCommit": true }
  ],
]